################################################
## Calibration of the Church Censorship Model
## Authors: Blasutto Fabio and David de la Croix
################################################

## remove (almost) everything in the working environment.
rm(list = ls())

#increase memory size
memory.limit(size=50000)

# to import xl files
library(readxl)

#to write excel files
require(writexl)

# to output towards latex
require(stargazer)

# for generating random variables
library(evd)

# for latex symbols in the graphs
library(latex2exp)

# genetic algorithm for estimation
library(GA)

# for a bootstraped CI
library(boot)


################################################
# PART 1: GET THE DATA
################################################

# set the directory to where the files are located
#setwd("C:\\Users\\ddlc\\Documents\\Dropbox\\01. Research\\UTHC main\\access database")
setwd("C:\\Users\\blasutto\\Dropbox\\Roman_Church_censorship_growth\\big base\\old")

#load database 
basew <- as.data.frame(read_excel("dictionary2.xlsx"))
basetot <- as.data.frame(read_excel("Profs.xlsx"))
membersa  <- as.data.frame(read_excel("Italian academies.xlsx"))
membersu  <- as.data.frame(read_excel("Italian universities.xlsx"))

members<-rbind(membersa,membersu)

#setwd("C:\\Users\\ddlc\\Documents\\Dropbox\\01. Research\\Roman_Church_censorship_growth\\data_work")
#setwd("C:\\Users\\Fabio\\Dropbox\\Roman_Church_censorship_growth\\data_work")
setwd("C:\\Users\\blasutto\\Dropbox\\Roman_Church_censorship_growth\\data_work")

#removing people without worldcat
members <- members[members$Worldcat!="NA",]

#removing people not yet checked
members <- members[members$Forbidden!=8888,]

# computing a ref date and removing people without dates
members$refdatel <- pmin(members$Beginning,members$DateApprox-5,
         members$YearBorn+30,members$End,members$YearDied,na.rm=T)
members<- members[!is.na(members$refdatel),]


#remove duplicates
members  <- members[!duplicated(members$Persons_PKey), ]
basew  <- basew[!duplicated(basew), ]
#members  <- members[!members$IKey=="AcadTurin-1757",]
members  <- members[members$refdatel>1400,]
members  <- members[!members$refdatel>1750,]
plist<-members$Persons_PKey
#Find the performance in the base generated by the wiki routine

# take the index of quality
members$perfl <- 0
basew$public<- basew$publications
#basew.pca <- prcomp(basew[,3:12], center = TRUE,scale. = TRUE)
for (j in plist){
members[members$Persons_PKey==j,"perfl"] <- log(max(c(basew[basew$PKey==j,"public"],1)))  # for individual quality
#members[members$Persons_PKey==j,"perfl"] <- log(basew.pca$x[j,1])
}


members<-members[!is.na(members$perfl),]

##########################
#Graph for stylized fact
###########################
pc <- c("grey40","red","grey83")
lim=50
t=seq(1400,1750,lim)
nn=numeric(length = length(t))
forb=numeric(length = length(t))
qual=numeric(length = length(t))
var=numeric(length = length(t))
CIqual=array(,c(2,length = length(t)))


members$cens<-0
members$cens[members$Forbidden<9999]<-1


for(i in 1:length(t)){
  
  forb[i]=mean(members$cens[members$refdatel>=t[i]-lim/2 & members$refdatel<t[i]+lim/2])
  qual[i]=mean(members$perfl[members$refdatel>=t[i]-lim/2 & members$refdatel<t[i]+lim/2])
  var[i]=var(members$perfl[members$refdatel>=t[i]-lim/2 & members$refdatel<t[i]+lim/2])
  nn[i]=length(members$perfl[members$refdatel>=t[i]-lim/2 & members$refdatel<t[i]+lim/2])
  CIqual[1,i]=qual[i]-qt(0.975,nn[i]-1)*(var[i]^(0.5))/sqrt(nn[i])
  CIqual[2,i]=qual[i]+qt(0.975,nn[i]-1)*(var[i]^(0.5))/sqrt(nn[i])
  
}



#The graph
setwd("C:\\Users\\blasutto\\Dropbox\\Roman_Church_censorship_growth\\paper")
plot.new()
pdf(file="qualtime.pdf", width = 10.3, height = 6)
par(oma = c(3, 1, 1, 1),
    mai=c(0.7,0.7,0.5,0.5),
    mgp=c(2,0.3,0)) # all plots on one page 
xrange <- range(t)
yrange <- c(min(CIqual),max(CIqual))
plot(xrange,yrange,type="n",
     ylab=TeX('Mean of Log(Publications)'),cex.lab=1.6,xlab='Time')
polygon(c(t,rev(t)),c(CIqual[1,],rev(CIqual[2,])),col =pc[3], border = FALSE)
abline(v=1559,col=pc[2])
text(1559,5.2,pos=4,"First Roman \n Index")
abline(v=1544,col=pc[2])
text(1544,5.2,pos=2,"First Index \n of the University \n of Paris")
lines(t,qual,type="l",col=pc[1],lwd=3)

dev.off()

################################################
# PART 2: COMPUTE THE MOMENTS
################################################

#We consider 4 periods here
threshold0<- (1559-63)#min(members$refdatel)
threshold1 <- 1559#round(quantile(members$refdatel,1/4),0)[[1]]
threshold2 <- 1559+63#round(quantile(members$refdatel,1/2),0)[[1]]
threshold3 <- 1559+63*2#round(quantile(members$refdatel,3/4),0)[[1]]
threshold4<-1559+63*3#max(members$refdatel)


threshold0<- min(members$refdatel)
threshold1 <- round(quantile(members$refdatel,1/4),0)[[1]]
threshold2 <- round(quantile(members$refdatel,1/2),0)[[1]]
threshold3 <- round(quantile(members$refdatel,3/4),0)[[1]]
threshold4<-max(members$refdatel)


members1 <- members[members$refdatel<threshold1,]
members2 <- members[threshold2>members$refdatel & members$refdatel>=threshold1,]
members3 <- members[threshold3>members$refdatel & members$refdatel>=threshold2,]
members4 <- members[members$refdatel>=threshold3,]


memberscensored1 <- members[members$Forbidden<9999 & members$refdatel<threshold1,]
membersnotcensored1 <- members[members$Forbidden==9999 & members$refdatel<threshold1,]

memberscensored2 <- members[members$Forbidden<9999 & 
threshold2>members$refdatel & members$refdatel>=threshold1,]
membersnotcensored2 <- members[members$Forbidden==9999 &
 threshold2>members$refdatel & members$refdatel>=threshold1,]

memberscensored3 <- members[members$Forbidden<9999 &
 threshold3>members$refdatel & members$refdatel>=threshold2,]
membersnotcensored3 <- members[members$Forbidden==9999 &
 threshold3>members$refdatel & members$refdatel>=threshold2,]

memberscensored4 <- members[members$Forbidden<9999 & members$refdatel>=threshold3,]
membersnotcensored4 <- members[members$Forbidden==9999 & members$refdatel>=threshold3,]


memberscensored <- members[members$Forbidden<9999 ,]
membersnotcensored <- members[members$Forbidden==9999 ,]

maxperf<-round(max(members$perfl)+0.5,)
maxpeople<-100/2

maxperfd <- 2* maxperf

bv<-(0:maxperfd)
bv<-bv/2


# get the k_t,K^theta_R and m_t*beta_t in the data
Embeta<-numeric(length=4)
Eqr<-numeric(length=4)
ENC<-numeric(length=4)
Eqc<-numeric(length=4)
Eq<-numeric(length=4)
Em<-numeric(length=4)
EqrQ75<-numeric(length=4)
ENCQ75<-numeric(length=4)
EqQ75<-numeric(length=4)
EqrM<-numeric(length=4)
ENCM<-numeric(length=4)
EqM<-numeric(length=4)

for (i in 1:4) {

    nam <- paste("members", i, sep = "")
    namc <- paste("memberscensored", i, sep = "")
    namnc <- paste("membersnotcensored", i, sep = "")
    
  #compute means
  Embeta[i]<-length(get(namc)$perfl)/(length(get(namc)$perfl)+ length(get(namnc)$perfl))
  Eqr[i]=mean(get(namc)$perfl)
  ENC[i]=mean(get(namnc)$perfl)
  Eq[i]=mean(get(nam)$perfl)
  
  #compute medians
  EqrM[i]=median(get(namc)$perfl)
  ENCM[i]=median(get(namnc)$perfl)
  EqM[i]=median(get(nam)$perfl)
  
  #compute 75 percentile
  EqrQ75[i]=quantile(get(namc)$perfl,0.75)
  ENCQ75[i]=quantile(get(namnc)$perfl,0.75)
  EqQ75[i]=quantile(get(nam)$perfl,0.75)
  
  
                                           
}
rm(nam,namc,namnc)

# get the variance of uality in the first period to get theta
Evar<-var(members1$perfl)
setwd("C:\\Users\\blasutto\\Dropbox\\Roman_Church_censorship_growth\\calibration")
################################################
# PART 3: ACTUAL CALIBRATION+ESTIMATION
################################################




####################################################
# Here I proceed with the estimation
##################################################

t<-numeric()
v<-numeric()
pe<-numeric()
z0<-numeric()
up<-numeric()
Sqc<-numeric(length=4)
Sqr<-numeric(length=4)
SNC<-numeric(length=4)
SNC75<-numeric(length=4)
Sq<-numeric(length=4)
pre<-numeric()
pre1<-numeric()
pre2<-numeric()
i<-numeric()
thet<-numeric()
eqrt<-numeric()
eqt<-numeric()
eqrtt<-numeric()
eqtt<-numeric()
# match initial conditions


# some functions to get the simulated variables

f<-function(x,the,k,pr,eqt,eqrt) {

  -eqt+(((eqrt/x)^(1/the))/((eqrt/x)^(1/the)+pr))*eqrt+
      (1-(((eqrt/x)^(1/the))/((eqrt/x)^(1/the)+pr)))*x}

fm<-function(x,the,k,pr,eqt,eqrt) {
  
  -eqt+(((eqrt/x)^(1/the))/((eqrt/x)^(1/the)+pr))*eqrt+
    (1-(((eqrt/x)^(1/the))/((eqrt/x)^(1/the)+pr)))*x}

zt<-function(beta,pe,t,up,thet,eqtt,eqrtt) {

    # get z0 first
    v=uniroot(f,c(0.00001,up),tol=0.00000001,maxiter=10000,the=thet,k=1,
                             pr=pe,eqt=eqtt,eqrt=eqrtt)
    z0=(eqrtt/v$root)^(1/thet)
    if(t>=2){pe/(1-beta)*(z0*(1-beta)/pe)^(2^(t-1))}else{z0}}
    
mt<-function(beta,pr,t,up,thet,eqtt,eqrtt) zt(beta,pr,t,up,thet,eqtt,eqrtt)/(pr+zt(beta,pr,t,up,thet,eqtt,eqrtt))

mbetat<-function(beta,pr,t,up,thet,eqtt,eqrtt) beta*mt(beta,pr,t,up,thet,eqtt,eqrtt)

qrs<-function(beta,pe,t,up,mu,pre,thet,eqtt,eqrtt) gamma(1-thet)*(mu*((1-beta)*(pre/gamma(1-thet))^(1/thet)*
                                   (mt(beta,pe,t-1,up,thet,eqtt,eqrtt))))^thet
                                   

qcs<-function(beta,pe,t,up,mu,pre,thet,eqtt,eqrtt) gamma(1-thet)*((mu*((pre/gamma(1-thet))^(1/thet)*
                                     (1-mt(beta,pe,t-1,up,thet,eqtt,eqrtt)))))^thet
                                    

qs<-function(beta,pe,t,up,mu,pre1,pre2,thet,eqtt,eqrtt) qrs(beta,pe,t,up,mu,pre1,thet,eqtt,eqrtt)*mt(beta,pe,t,up,thet,eqtt,eqrtt)+
                                    (1-mt(beta,pe,t,up,thet,eqtt,eqrtt))*qcs(beta,pe,t,up,mu,pre2,thet,eqtt,eqrtt)

nc<-function(beta,pe,t,up,mu,pre1,pre2,thet,eqtt,eqrtt) qrs(beta,pe,t,up,mu,pre1,thet,eqtt,eqrtt)*
                                     (((1-beta)*mt(beta,pe,t,up,thet,eqtt,eqrtt))/(1-beta*mt(beta,pe,t,up,thet,eqtt,eqrtt)))+
                                    ((1-mt(beta,pe,t,up,thet,eqtt,eqrtt))/(1-beta*mt(beta,pe,t,up,thet,eqtt,eqrtt)))*
                                    qcs(beta,pe,t,up,mu,pre2,thet,eqtt,eqrtt)
                                         

 #GUARDA A INITIAL CONDITION CIU C
  
# define the function that we want to minimize taking beta
maxg<-1000
max<-numeric()
maxx<-numeric()
muu<-numeric()
betaa<-numeric()
sum<-numeric(length=1)
MT<-numeric()
MR<-numeric()
MT75<-numeric()
MR75<-numeric()
upper<-seq(0.01,200,length.out=maxg)



#parameters for the simulation

mini<-function(betaa,pe,muu,thet){
  sum=0     

        Sqr[1]= ((log(2))^thet)*gamma(1-thet)*EqrM[1]
        Sq[1]= ((log(2))^thet)*gamma(1-thet)*EqM[1]

        Sqr[1]=Eqr[1]
        Sq[1]=Eq[1]
    # first check that I can find a Kc that rationalize data with
    # current parameter
    for(j in maxg:1){

      if(f(0.00001,thet,1,pe,Sq[1],Sqr[1])*f(upper[j],thet,1,pe,Sq[1],Sqr[1])<0){

          maxx=upper[j]
          break}
          
        maxx=400}

    # compute tha loss function
    if(f(0.00001,thet,1,pe,Sq[1],Sqr[1])*f(maxx,thet,1,pe,Sq[1],Sqr[1])>0){return(10000)}

      # get Sqc[1],Eqc[1] consistent with parameters
      v=uniroot(f,c(0.00001,maxx),tol=0.00000001,maxiter=10000,the=thet,k=1,pr=pe,
                                  eqt=Sq[1],eqrt=Sqr[1])
      Eqc[1]<-v$root
      Sqc[1]=Eqc[1]


      for(i in 1:4){
          if(i>=2){
            
          Sqc[i]<-qcs(betaa,pe,i,maxx,muu,Sqc[i-1],thet,Sq[1],Sqr[1])
          Sqr[i]<-qrs(betaa,pe,i,maxx,muu,Sqr[i-1],thet,Sq[1],Sqr[1])
          Sq[i] <-qs(betaa,pe,i,maxx,muu,Sqr[i-1],Sqc[i-1],thet,Sq[1],Sqr[1])          
           
      }}
        
            
    
     
      
      for (i in 1:4){
        mcur<-mt(betaa,pe,i,maxx,thet,Sq[1],Sqr[1])        
        sum=sum+((mcur*betaa-Embeta[i])/Embeta[i])^2
        
      
        
        if(i>=2){
          
          #Moments with average
       
        MT[i]<-(((qs(betaa,pe,i,maxx,muu,Sqr[i-1],Sqc[i-1],thet,Sq[1],Sqr[1])/(gamma(1-thet)))^(1/1))/
             ((log(2))^thet))
        MR[i]<-(((qrs(betaa,pe,i,maxx,muu,Sqr[i-1],thet,Sq[1],Sqr[1])/(gamma(1-thet)))^(1/1))/
             ((log(2))^thet))
        
        MT75[i]<-(((qs(betaa,pe,i,maxx,muu,Sqr[i-1],Sqc[i-1],thet,Sq[1],Sqr[1])/(gamma(1-thet)))^(1/1))/
               ((log(4/3))^thet))
        MR75[i]<-(((qrs(betaa,pe,i,maxx,muu,Sqr[i-1],thet,Sq[1],Sqr[1])/(gamma(1-thet)))^(1/1))/
               ((log(4/3))^thet))
         
        
        
        
        
        sum=sum+((MT[i]-EqM[i])/EqM[i])^2
        sum=sum+((MT75[i]-EqQ75[i])/EqQ75[i])^2
        sum=sum+((MR[i]-EqrM[i])/EqrM[i])^2
        sum=sum+((MR75[i]-EqrQ75[i])/EqrQ75[i])^2
       

        
        }else{

        #Median & 75 percentile
        MT[1]<-(((Sq[1]/(gamma(1-thet)))^(1/1))/
               ((log(2))^thet))
        MR[1]<-(((Sqr[1]/(gamma(1-thet)))^(1/1))/
               ((log(2))^thet))
        
        MT75[1]<-(((Sq[1]/(gamma(1-thet)))^(1/1))/
               ((log(4/3))^thet))
        MR75[1]<-(((Sqr[1]/(gamma(1-thet)))^(1/1))/
               ((log(4/3))^thet))

        sum=sum+((MT[1]-EqM[1])/EqM[1])^2
        sum=sum+((MT75[1]-EqQ75[1])/EqQ75[1])^2
        sum=sum+((MR[1]-EqrM[1])/EqrM[1])^2
        sum=sum+((MR75[1]-EqrQ75[1])/EqrQ75[1])^2}}
        
     # if(mt(betaa,pe,1,maxx,thet)<0.5){sum=10000}      
        
        return(sum)}
  

  ff<-function(x) -mini(x[1],x[2],x[3],x[4])


  # call the genetic alogorithm for the estimation
  GA <- ga(type = "real-valued", 
           fitness = ff, 
           lower = c(0,20,0.1,0.15),
           upper = c(0.7,850,8,0.4),
           popSize = 200, maxiter = 80, run = 20,
           elitism = max(1, round(200*0.15)),
           pcrossover = 0.8,
           pmutation = 0.9,
           keepBest = TRUE,
           optim=FALSE,
           optimArgs = list(method = "L-BFGS-B",poptim = 0.6,pressel = 0.2,
             control = list(fnscale = -1, maxit = 20)))

  # visualize the solution 
  summary(GA)
  plot(GA)

  beta<-GA@solution[1,1]
  p<-GA@solution[1,2]
  mu<-GA@solution[1,3]
  theta<-GA@solution[1,4]


  
  # compute empirical and non empirical
n<-5150 #how many draws from distribution
B=numeric(length=n)
B1=numeric(length=n)
Bc=numeric(length=n)
Br=numeric(length=n)
B1=runif(n, min = 0, max = 1)  # shocks for deciding later from which distribution to draw




  Smbeta=numeric(length=4)
  Sz=numeric(length=4)
  Sm=numeric(length=4)
  Ez=numeric(length=4)
  Em=numeric(length=4)
  SqrM<-numeric(length=4)
  SNCM<-numeric(length=4)
  SqM<-numeric(length=4)
  SqrQ75<-numeric(length=4)
  SNCQ75<-numeric(length=4)
  SqQ75<-numeric(length=4)

        Sqr[1]= ((log(2))^theta)*gamma(1-theta)*EqrM[1]
        Sq[1]= ((log(2))^theta)*gamma(1-theta)*EqM[1]

        Sqr[1]=Eqr[1]
        Sq[1]=Eq[1]

  for(j in maxg:1){



    #  if(f(0.001,theta,1,p)*f(upper[j],theta,1,p)<0 & f(0.001,theta,2,p)*f(upper[j],theta,2,p)<0 &
     # f(0.001,theta,3,p)*f(upper[j],theta,3,p)<0 & f(0.001,theta,4,p)*f(upper[j],theta,4,p)<0){
      if(f(0.00001,theta,1,p,Sq[1],Sqr[1])*f(upper[j],theta,1,p,Sq[1],Sqr[1])<0){
      max=upper[j]
      break}}

       
  for(i in 1:4){

    Sm[i]=mt(beta,p,i,max,theta,Sq[1],Sqr[1])
    Sz[i]=zt(beta,p,i,max,theta,Sq[1],Sqr[1])
    Smbeta[i]=mbetat(beta,p,i,max,theta,Sq[1],Sqr[1])

    #v=uniroot(f,c(0.00001,max),tol=0.0001,maxiter=100,the=theta,k=i,pr=p)
    #Eqc[i]=v$root
    v=uniroot(f,c(0.00001,max),tol=0.0001,maxiter=100,the=theta,k=1,pr=p,eqt=Sq[1],eqrt=Sqr[1])
    Eqc[1]=v$root
    Sqc[1]=Eqc[1]
    Ez[i]=(Eqr[i]/Eqc[i])^(1/theta)
    Em[i]=Ez[i]/(p+Ez[i])
    
    

    if(i>=2){
     
      Sqc[i]=qcs(beta,p,i,max,mu,Sqc[i-1],theta,Sq[1],Sqr[1])
      Sqr[i]=qrs(beta,p,i,max,mu,Sqr[i-1],theta,Sq[1],Sqr[1])
      Sq[i]=qs(beta,p,i,max,mu,Sqr[i-1],Sqc[i-1],theta,Sq[1],Sqr[1])
      SNC[i]=nc(beta,p,i,max,mu,Sqr[i-1],Sqc[i-1],theta,Sq[1],Sqr[1])
      
      #median
      SqM[i]=(((Sq[i]/(gamma(1-theta)))^(1/1))/
                ((log(2))^theta))
      SqrM[i]=(((Sqr[i]/(gamma(1-theta)))^(1/1))/
                 ((log(2))^theta))
      SqQ75[i]=(((Sq[i]/(gamma(1-theta)))^(1/1))/
                ((log(4/3))^theta))
      SqrQ75[i]=(((Sqr[i]/(gamma(1-theta)))^(1/1))/
                 ((log(4/3))^theta))
      
      # draw random realization from the two frechet distibutions
      Br=rfrechet(n, loc=0, 
                  scale=(qrs(beta,p,i,max,mu,Sqr[i-1],theta,Sq[1],Sqr[1])/(gamma(1-theta))),
                  shape=1/theta)
      
      Bc=rfrechet(n, loc=0, 
                  scale=qcs(beta,p,i,max,mu,Sqc[i-1],theta,Sq[1],Sqr[1])/(gamma(1-theta)),
                  shape=1/theta)
      
      for (j in 1:n) {if (B1[j]>mt(beta,p,i,max,theta,Sq[1],Sqr[1])) {B[j]=Bc[j]} else {B[j]=Br[j]}}
      SNCM[i]=median(B)
      SNCQ75[i]=quantile(B,0.75)
      
    }else{


     
   
     
      SqQ75[1]=(((Sq[1]/(gamma(1-theta)))^(1/1))/
                  ((log(4/3))^theta))
      SqrQ75[1]=(((Sqr[1]/(gamma(1-theta)))^(1/1))/
                  ((log(4/3))^theta))
      SqM[1]=(((Sq[1]/(gamma(1-theta)))^(1/1))/
                ((log(2))^theta))
      SqrM[1]=(((Sqr[1]/(gamma(1-theta)))^(1/1))/
                ((log(2))^theta))
      SNC[1]=Sqr[1]*
        (((1-beta)*mt(beta,p,i,max,theta,Sq[1],Sqr[1]))/(1-beta*mt(beta,p,i,max,theta,Sq[1],Sqr[1])))+
        ((1-mt(beta,p,i,max,theta,Sq[1],Sqr[1]))/(1-beta*mt(beta,p,i,max,theta,Sq[1],Sqr[1])))*
        Sqc[1]
      
      # draw random realization from the two frechet distibutions
      Br=rfrechet(n, loc=0, 
                  scale=Sqr[1]/(gamma(1-theta)),
                  shape=1/theta)
      
      Bc=rfrechet(n, loc=0, 
                  scale=Sqc[1]/gamma(1-theta),
                  shape=1/theta)
      
      for (j in 1:n) {if (B1[j]>mt(beta,p,1,max,theta,Sq[1],Sqr[1])) {B[j]=Bc[j]} else {B[j]=Br[j]}}
      SNCM[1]=median(B)
      SNCQ75[1]=quantile(B,0.75)
      
      }
    

    
    }

##################################
# get bootstraped CI for graph
##################################
ns<-length(members$perfl)
nboots<-1000
boots<-numeric(ns)
Bmbeta<-array(,c(4,nboots))
Bq<-array(,c(4,nboots))
BNC<-array(,c(4,nboots))
Bqr<-array(,c(4,nboots))
Bq75<-array(,c(4,nboots))
BNC75<-array(,c(4,nboots))
Bqr75<-array(,c(4,nboots))
rm(.Random.seed, envir=globalenv())
#aa<-replicate(nboots, sample(members, ns,replace=TRUE))
for(i in 1:nboots){

  
  boots<-as.data.frame(sample(members$Persons_PKey,ns,replace=TRUE))
  memb<-merge(boots,members,
    by.x='sample(members$Persons_PKey, ns, replace = TRUE)',
    by.y='Persons_PKey')

  # compute what we need
  #memb<-members[boots%in% members$Persons_PKey]
  #memb<-subset(members,members$Persons_PKey==boots)

  #We consider 4 periods here
 # members1 <- memb[memb$refdatel<threshold1,]
#  members2 <- memb[threshold2>memb$refdatel & memb$refdatel>=threshold1,]
 # members3 <- memb[threshold3>memb$refdatel & memb$refdatel>=threshold2,]
  #members4 <- memb[memb$refdatel>=threshold3,]
  
  boots<-as.data.frame(sample(members1$Persons_PKey,length(members1$perfl),replace=TRUE))
  amembers1<-merge(boots,members1,
              by.x='sample(members1$Persons_PKey, length(members1$perfl), replace = TRUE)',
              by.y='Persons_PKey')
  
  boots<-as.data.frame(sample(members2$Persons_PKey,length(members2$perfl),replace=TRUE))
  amembers2<-merge(boots,members2,
                  by.x='sample(members2$Persons_PKey, length(members2$perfl), replace = TRUE)',
                  by.y='Persons_PKey')
  
  boots<-as.data.frame(sample(members3$Persons_PKey,length(members3$perfl),replace=TRUE))
  amembers3<-merge(boots,members3,
                  by.x='sample(members3$Persons_PKey, length(members3$perfl), replace = TRUE)',
                  by.y='Persons_PKey')
  
  boots<-as.data.frame(sample(members4$Persons_PKey,length(members4$perfl),replace=TRUE))
  amembers4<-merge(boots,members4,
                  by.x='sample(members4$Persons_PKey, length(members4$perfl), replace = TRUE)',
                  by.y='Persons_PKey')


  memberscensored1 <- amembers1[amembers1$Forbidden<9999 ,]
  membersnotcensored1 <- amembers1[amembers1$Forbidden==9999,]

  memberscensored2 <- amembers2[amembers2$Forbidden<9999,]
  membersnotcensored2 <- amembers2[amembers2$Forbidden==9999,]
  
  memberscensored3 <- amembers3[amembers3$Forbidden<9999,]
  membersnotcensored3 <- amembers3[amembers3$Forbidden==9999,]
  
  memberscensored4 <- amembers4[amembers4$Forbidden<9999,]
  membersnotcensored4 <- amembers4[amembers4$Forbidden==9999,]



 # memberscensored <- memb[memb$Forbidden<9999 ,]

  #the moments now
  for(j in 1:4){

  nam <- paste("amembers", j, sep = "")
  namc <- paste("memberscensored", j, sep = "")
  namnc <- paste("membersnotcensored", j, sep = "")
    
  Bmbeta[j,i]<-length(get(namc)$perfl)/(length(get(namc)$perfl)+ length(get(namnc)$perfl))
  Bqr[j,i]=median(get(namc)$perfl)
  Bq[j,i]=median(get(nam)$perfl)
  BNC[j,i]=median(get(namnc)$perfl)
  Bqr75[j,i]=quantile(get(namc)$perfl,0.75)
  Bq75[j,i]=quantile(get(nam)$perfl,0.75)
  BNC75[j,i]=quantile(get(namnc)$perfl,0.75)
  
  }}

  #get finally the CI
  CImbeta<-array(,c(2,4))
  CIq<-array(,c(2,4))
  CIqr<-array(,c(2,4))
  CINC<-array(,c(2,4))
  CImbeta75<-array(,c(2,4))
  CIq75<-array(,c(2,4))
  CIqr75<-array(,c(2,4))
  CINC75<-array(,c(2,4))

  for(j in 1:4){
  CImbeta[,j]<-quantile(Bmbeta[j,],c(0.025,0.975))
  CIq[,j]<-quantile(Bq[j,],c(0.025,0.975))
  CIqr[,j]<-quantile(Bqr[j,],c(0.025,0.975))
  CINC[,j]<-quantile(BNC[j,],c(0.025,0.975))
  CIq75[,j]<-quantile(Bq75[j,],c(0.025,0.975))
  CIqr75[,j]<-quantile(Bqr75[j,],c(0.025,0.975))
  CINC75[,j]<-quantile(BNC75[j,],c(0.025,0.975))
  
  }




  #################################
  # graph to visualize the reults
  #################################
  setwd("C:\\Users\\blasutto\\Dropbox\\Roman_Church_censorship_growth\\paper")
# function for more than one title per graph
line2user <- function(line, side) {
  lh <- par('cin')[2] * par('cex') * par('lheight')
  x_off <- diff(grconvertX(0:1, 'inches', 'user'))
  y_off <- diff(grconvertY(0:1, 'inches', 'user'))
  switch(side,
         `1` = par('usr')[3] - line * y_off * lh,
         `2` = par('usr')[1] - line * x_off * lh,
         `3` = par('usr')[4] + line * y_off * lh,
         `4` = par('usr')[2] + line * x_off * lh,
         stop("side must be 1, 2, 3, or 4", call.=FALSE))
}

  # set up something about the graph
  time=seq(1,4,1) 
    timee=c(paste(threshold0,'-',threshold1),
         paste(threshold1,'-',threshold2),
         paste(threshold2,'-',threshold3),
         paste(threshold3,'-',threshold4))
  pc <- c("grey40","red","grey83")
  pdf(file="fit.pdf", width = 8, height = 10)
  par(mfrow=c(3,2),oma = c(3, 0.5, 0.5, 0.5), mgp=c(2,0.3,0)) # all plots on one page 
                                      


  #q
  xrange <- range(time)
  yrange <- c(0,2*max(EqM,SqM)-min(EqM,SqM))
  plot(xrange,yrange,type="n", xlab="Time",
   ylab=TeX('$q_t(50p)$'),cex.lab=1.6,xaxt='n')
  axis(1, at=1:4,labels=timee,font=2)
  polygon(c(time,rev(time)),c(CIq[1,],rev(CIq[2,])),col =pc[3], border = FALSE,axes=F)
  lines(time,EqM,type="l",col=pc[1],lwd=3)
  lines(time,SqM,type="l",col=pc[2],lty=2,lwd=3)
  
  #q
  xrange <- range(time)
  yrange <- c(0,2*max(EqQ75,SqQ75)-min(EqQ75,SqQ75))
  plot(xrange,yrange,type="n", xlab="Time",
       ylab=TeX('$q_t(75p)$'),cex.lab=1.6,xaxt='n')
  axis(1, at=1:4,labels=timee,font=2)
  polygon(c(time,rev(time)),c(CIq75[1,],rev(CIq75[2,])),col =pc[3], border = FALSE,axes=F)
  lines(time,EqQ75,type="l",col=pc[1],lwd=3)
  lines(time,SqQ75,type="l",col=pc[2],lty=2,lwd=3)
  

  #First Title
  text(line2user(line=mean(par('mar')[c(2, 4)]), side=2), 
       line2user(line=2, side=3), 'Targeted Moments', xpd=NA, cex=2, font=2)
  
      #qr
  yrange <- c(0,2*max(EqrM,SqrM)-min(EqrM,SqrM))
  plot(xrange,yrange,type="n", xlab="Time",
   ylab=TeX('$q^R_t(50p)$'),cex.lab=1.6,xaxt='n')
  axis(1, at=1:4,labels=timee,font=2)
  polygon(c(time,rev(time)),c(CIqr[1,],rev(CIqr[2,])),col =pc[3], border = FALSE)
  lines(time,EqrM,type="l",col=pc[1],lwd=3)
  lines(time,SqrM,type="l",col=pc[2],lty=2,lwd=3)

  
  #qr
  yrange <- c(0,2*max(EqrQ75,SqrQ75)-min(EqrQ75,SqrQ75))
  plot(xrange,yrange,type="n", xlab="Time",
       ylab=TeX('$q^R_t(75p)$'),cex.lab=1.6,xaxt='n')
  axis(1, at=1:4,labels=timee,font=2)
   polygon(c(time,rev(time)),c(CIqr75[1,],rev(CIqr75[2,])),col =pc[3], border = FALSE)
  lines(time,EqrQ75,type="l",col=pc[1],lwd=3)
  lines(time,SqrQ75,type="l",col=pc[2],lty=2,lwd=3)
  
  
  # m*Beta
  xrange <- range(time)
  yrange <- c(0,2*max(Embeta,Smbeta)-min(Embeta,Smbeta))
  plot(xrange,yrange,type="n", xlab="Time",
       ylab=TeX('$m_t\\beta_t$'),cex.lab=1.6,xaxt='n')
  axis(1, at=1:4,labels=timee,font=2)
   polygon(c(time,rev(time)),c(CImbeta[1,],rev(CImbeta[2,])),col =pc[3], border = FALSE)
  lines(time,Embeta,type="l",col=pc[1],lwd=3)
  lines(time,Smbeta,type="l",col=pc[2],lty=2,lwd=3)

   plot.new()


   # add an external legend
   par(fig = c(0, 1, 0, 1), oma = c(0, 0, 0, 0), mar = c(0, 0, 0, 0), new = TRUE)
   plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n")
   legend("bottom", legend = c("Data", "Simulation"), 
          col=pc, lwd=2.5, cex=2, lty=c(1,2), horiz = TRUE,xpd=TRUE,bty = 'n',inset = c(0.1,0))
   dev.off()
   
   #Here Over identification
   
   
   pdf(file="over.pdf", width = 10, height = 7)
   par(mfrow=c(1,2),oma = c(3, 0.5, 0.5, 0.5), mgp=c(2,0.3,0)) # all plots on one page 

#nc
  yrange <- c(0,2*max(ENCM,SNCM)-min(ENCM,SNCM))
  plot(xrange,yrange,type="n", xlab="Time",
   ylab=TeX('$q_t$(not censored,50p)'),cex.lab=1.6,xaxt='n' )
  axis(1, at=1:4,labels=timee,font=2)
  polygon(c(time,rev(time)),c(CINC[1,],rev(CINC[2,])),col =pc[3], border = FALSE)
  lines(time,ENCM,type="l",col=pc[1],lwd=3)
  lines(time,SNCM,type="l",col=pc[2],lty=2,lwd=3)
  
  
  #nc
  yrange <- c(0,2*max(ENCQ75,SNCQ75)-min(ENCQ75,SNCQ75))
  plot(xrange,yrange,type="n", xlab="Time",
       ylab=TeX('$q_t$(not censored,75p)'),cex.lab=1.6,xaxt='n' )
  axis(1, at=1:4,labels=timee,font=2)
  polygon(c(time,rev(time)),c(CINC75[1,],rev(CINC75[2,])),col =pc[3], border = FALSE)
  lines(time,ENCQ75,type="l",col=pc[1],lwd=3)
  lines(time,SNCQ75,type="l",col=pc[2],lty=2,lwd=3)



  #Second Title
  text(line2user(line=mean(par('mar')[c(2, 4)]), side=2), 
  line2user(line=2, side=3), 'Over-Identified moments', xpd=NA, cex=2, font=2)


  # add an external legend
  par(fig = c(0, 1, 0, 1), oma = c(0, 0, 0, 0), mar = c(0, 0, 0, 0), new = TRUE)
  plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n")
  legend("bottom", legend = c("Data", "Simulation"), 
        col=pc, lwd=2.5, cex=2, lty=c(1,2), horiz = TRUE,xpd=TRUE,bty = 'n',inset = c(0.1,0))
  dev.off()


 
  ##########################################
  # counterfactual experiment: no censorship
  ##########################################
  SzC=numeric(length=4)
  SmC=numeric(length=4)
  SmbetaC=numeric(length=4)
  SqcC=numeric(length=4)
  SqrC=numeric(length=4)
  SqC=numeric(length=4)
  for(i in 1:4){

    SmC[i]=mt(0,p,i,max,theta,Sq[1],Sqr[1])
    SzC[i]=zt(0,p,i,max,theta,Sq[1],Sqr[1])
    SmbetaC[i]=mbetat(0,p,i,max,theta,Sq[1],Sqr[1])


    if(i>=2){
     
      SqcC[i]=qcs(0,p,i,max,mu,SqcC[i-1],theta,Sq[1],Sqr[1])
      SqrC[i]=qrs(0,p,i,max,mu,SqrC[i-1],theta,Sq[1],Sqr[1])
      SqC[i]=qs(0,p,i,max,mu,SqrC[i-1],SqcC[i-1],theta,Sq[1],Sqr[1])
    }else{

      SqcC[1]=Sqc[1]
      SqC[1]=Sq[1]
      SqrC[1]=Sqr[1]}}

  # second graph to visualize the variables all at once
  # set up something about the graph

  pdf(file="dynamics.pdf", width = 10.3, height = 5)
  par(mfrow=c(2,3),oma = c(3, 1, 1, 1),
                  mai=c(0.5,0.5,0.5,0.5),
                  mgp=c(2,0.3,0)) # all plots on one page 

  # m*Beta
  xrange <- range(time)
  yrange <- c(0,2*max(SmbetaC,Smbeta)-min(SmbetaC,Smbeta))
  plot(xrange,yrange,type="n", xlab="Time",
   ylab=TeX('$m_t\\beta_t$'),cex.lab=1.6,xaxt='n')
  lines(time,Smbeta,type="l",col=pc[1],lwd=2)
  lines(time,SmbetaC,type="l",col=pc[2],lty=2,lwd=2)
  axis(1, at=1:4,labels=timee,font=2)

  # m
  yrange <- c(0,2*max(SmC,Sm)-min(SmC,Sm))
  plot(xrange,yrange,type="n", xlab="Time",
   ylab=TeX('$m_t$'),cex.lab=1.5,xaxt='n')
  axis(1, at=1:4,labels=timee,font=2)
  lines(time,Sm,type="l",col=pc[1],lwd=2)
  lines(time,SmC,type="l",col=pc[2],lty=2,lwd=2)

  # z
  yrange <- c(0,2*max(SzC,Sz)-min(SzC,Sz))
  plot(xrange,yrange,type="n", xlab="Time",
   ylab=TeX('$z_t$'),cex.lab=1.5,xaxt='n')
  axis(1, at=1:4,labels=timee,font=2)
  lines(time,Sz,type="l",col=pc[1],lwd=2)
  lines(time,SzC,type="l",col=pc[2],lty=2,lwd=2)

  #q
  yrange <- c(0,2*max(SqC,Sq)-min(SqC,Sq))
  plot(xrange,yrange,type="n", xlab="Time",
   ylab=TeX('$q_t$'),cex.lab=1.5,xaxt='n')
  axis(1, at=1:4,labels=timee,font=2)
  lines(time,Sq,type="l",col=pc[1],lwd=2)
  lines(time,SqC,type="l",col=pc[2],lty=2,lwd=2)

  #qr
  yrange <- c(0,2*max(SqrC,Sqr)-min(SqrC,Sqr))
  plot(xrange,yrange,type="n", xlab="Time",
   ylab=TeX('$q^R_t$'),cex.lab=1.5,xaxt='n')
  axis(1, at=1:4,labels=timee,font=2)
  lines(time,Sqr,type="l",col=pc[1],lwd=2)
  lines(time,SqrC,type="l",col=pc[2],lty=2,lwd=2)

  #qc
    yrange <- c(0,2*max(SqcC,Sqc)-min(SqcC,Sqc))
  plot(xrange,yrange,type="n", xlab="Time",
   ylab=TeX('$q^C_t$'),cex.lab=1.5,xaxt='n')
  axis(1, at=1:4,labels=timee,font=2)
  lines(time,Sqc,type="l",col=pc[1],lwd=2)
  lines(time,SqcC,type="l",col=pc[2],lty=2,lwd=2)

  # add an external legend
  par(fig = c(0, 1, 0, 1), oma = c(0, 0, 0, 0), mar = c(0, 0, 0, 0), new = TRUE)
  plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n")
  legend("bottom", legend = c( "Simulation",TeX('$Countertfactual:\\beta_t=0$')), 
        col=pc, lwd=3, cex=2,horiz = TRUE,xpd=TRUE,bty = 'n',inset = c(0.1,0))
  dev.off()

  

    
    #Build the tables for the paper
    sink("temp.Rnw")
  
    cat(paste('\\begin{table}[htpb]
    \\caption{Identification of Parameters}
    \\centering % used for centering table
    \\begin{tabular}{@{} l c c c @{}}  
    \\hline%inserts double horizontal lines
    \\ External Parameters &  & Value & Target  \\\\ [0.05ex] % inserts table
      %heading
    \\hline % inserts single horizontal line
    \\rule{0pt}{2.5ex}
    Mean quality in 1  & $\\overline{q}_1$   &',round(Sq[1], digits=2),'& First period median quality  \\\\[0.15ex]
    Mean rev. quality in 1  & $\\overline{q}^R_1$   &',round(Sqr[1], digits=2),'& First period median quality \\\\[0.15ex]
    \\hline 
    \\ Estimated Parameters &  & Value &  \\\\ [0.05ex] % inserts table
    \\hline
     Productivity of books  & $\\theta$   &',round(theta, digits=2),'& MSM  \\\\[0.15ex]
    \\ \\%censored revolutionary books  & $\\overline{\\beta}$   &',round(beta, digits=2),'& MSM  \\\\[0.15ex]
    TFP  & $(1+\\nu)\\mu$   &',round(mu, digits=2),'& MSM  \\\\[0.15ex]
    Price of revolutionary books   & $p$   &',round(p^(-theta), digits=2),'& MSM  \\\\[0.15ex]
    \\hline
    \\end{tabular}
    \\label{Tab:param}
    \\end{table}'))
  
    sink()
    Sweave("temp.Rnw")
  
    
  
  #A final computation of the Impact on knowledge
    
    #overall drop
    print((Sq[4]-SqC[4])/SqC[4])
    
    #decomposition of the drop
    print(((SmC[4]*Sqr[4]+(1-SmC[4])*Sqc[4])-SqC[4])/Sq[4])
